#pragma once

#include "esphome/core/component.h"
#include "esphome/components/sensor/sensor.h"
#include "esphome/components/text_sensor/text_sensor.h"
#include "esphome/components/uart/uart.h"
#include "esphome/core/log.h"
#include "esphome/core/defines.h"

#include "parser.h"
#include "reader.h"
#include "fields.h"

namespace esphome {
namespace dsmr_ {

static const char* TAG = "dsmr";

static constexpr uint32_t P1_MAXTELEGRAMLENGTH = 1500;
static constexpr uint32_t POLL_TIMEOUT = 1000;

using namespace dsmr::fields;

// DSMR_**_LIST generated by ESPHome and written in esphome/core/defines

#if defined(DSMR_SENSOR_LIST) && defined(DSMR_TEXT_SENSOR_LIST)
#define DSMR_BOTH ,
#else
#define DSMR_BOTH
#endif

#ifndef DSMR_SENSOR_LIST
#define DSMR_SENSOR_LIST(F, SEP)
#endif

#ifndef DSMR_TEXT_SENSOR_LIST
#define DSMR_TEXT_SENSOR_LIST(F, SEP)
#endif

#define DSMR_DATA_SENSOR(s) s
#define COMMA ,

using MyData = dsmr::ParsedData<DSMR_TEXT_SENSOR_LIST(DSMR_DATA_SENSOR, COMMA)
                                    DSMR_BOTH DSMR_SENSOR_LIST(DSMR_DATA_SENSOR, COMMA)>;

class Dsmr : public PollingComponent, public uart::UARTDevice {
 public:
  Dsmr(uart::UARTComponent* uart) : uart::UARTDevice(uart) {}

  void update() override { poll_ = millis(); }

  void loop() override {
    if (poll_ == 0)
      return;

    while (available()) {
      const char c = read();

      if (c == '/') {  // header: forward slash
        ESP_LOGV(TAG, "Header found");
        header_found_ = true;
        footer_found_ = false;
        telegram_len_ = 0;
      }

      if (!header_found_)
        continue;
      if (telegram_len_ >= P1_MAXTELEGRAMLENGTH) {  // Buffer overflow
        header_found_ = false;
        footer_found_ = false;
        ESP_LOGE(TAG, "Error: Message larger than buffer");
      }

      telegram_[telegram_len_] = c;
      telegram_len_++;
      if (c == '!') {  // footer: exclamation mark
        ESP_LOGV(TAG, "Footer found");
        footer_found_ = true;
      } else {
        if (footer_found_ && c == 10) {  // last \n after footer
          header_found_ = false;
          // Parse message
          MyData data;
          ESP_LOGD(TAG, "Trying to parse");
          ::dsmr::ParseResult<void> res =
              ::dsmr::P1Parser::parse(&data, telegram_, telegram_len_,
                                      false);  // Parse telegram accoring to data definition. Ignore unknown values.
          if (res.err) {
            // Parsing error, show it
            auto err_str = res.fullError(telegram_, telegram_ + telegram_len_).c_str();
            ESP_LOGE(TAG, "%s", res.err);
          } else {
            poll_ = 0;
            this->status_clear_warning();
            publish_sensors(data);
            return;
          }
        }
      }
    }
    if (millis() - poll_ > POLL_TIMEOUT) {
      ESP_LOGE(TAG, "No data available. Is P1 port connected?");
      poll_ = 0;
      this->status_set_warning();
    }
  }

  void publish_sensors(MyData data) {
#define DSMR_PUBLISH_SENSOR(s) \
  if (data.s##_present && this->s_##s##_ != nullptr) \
    s_##s##_->publish_state(data.s);
    DSMR_SENSOR_LIST(DSMR_PUBLISH_SENSOR, )

#define DSMR_PUBLISH_TEXT_SENSOR(s) \
  if (data.s##_present && this->s_##s##_ != nullptr) \
    s_##s##_->publish_state(data.s.c_str());
    DSMR_TEXT_SENSOR_LIST(DSMR_PUBLISH_TEXT_SENSOR, )
  };

  void dump_config() override {
    ESP_LOGCONFIG(TAG, "dsmr:");

#define DSMR_LOG_SENSOR(s) LOG_SENSOR("  ", #s, this->s_##s##_);
    DSMR_SENSOR_LIST(DSMR_LOG_SENSOR, )

#define DSMR_LOG_TEXT_SENSOR(s) LOG_TEXT_SENSOR("  ", #s, this->s_##s##_);
    DSMR_TEXT_SENSOR_LIST(DSMR_LOG_TEXT_SENSOR, )
  }

  // Sensor setters
#define DSMR_SET_SENSOR(s) \
  void set_##s(sensor::Sensor* sensor) { s_##s##_ = sensor; }
  DSMR_SENSOR_LIST(DSMR_SET_SENSOR, )

#define DSMR_SET_TEXT_SENSOR(s) \
  void set_##s(text_sensor::TextSensor* sensor) { s_##s##_ = sensor; }
  DSMR_TEXT_SENSOR_LIST(DSMR_SET_TEXT_SENSOR, )

 protected:
  char telegram_[P1_MAXTELEGRAMLENGTH];
  int telegram_len_{0};
  bool header_found_{false};
  bool footer_found_{false};
  uint32_t poll_{0};

  // Sensor member pointers
#define DSMR_DECLARE_SENSOR(s) sensor::Sensor* s_##s##_{nullptr};
  DSMR_SENSOR_LIST(DSMR_DECLARE_SENSOR, )

#define DSMR_DECLARE_TEXT_SENSOR(s) text_sensor::TextSensor* s_##s##_{nullptr};
  DSMR_TEXT_SENSOR_LIST(DSMR_DECLARE_TEXT_SENSOR, )
};
}  // namespace dsmr_
}  // namespace esphome
